### 锁
- 全局锁
- 表级锁
- 行锁

### 全局锁
- 对整个数据库实例加锁
- `Flush tables with read lock`
- 需要整个数据库处于只读状态的时候可以加锁
- 执行命令连接断开后，数据库恢复可写状态
- 阻塞以下语句
	- 数据的增删改查
	- 数据定义语句，包括建表和修改表结构语句
	- 更新类事务的提交语句
	- 典型使用场景，全库逻辑备份

### 表级锁
- 表锁
- MDL metadata lock元数据锁

### 表锁
- `lock tables ... read/write`
- `unlock tables` 主动释放锁
- 锁住其他线程和自己本身

### MDL锁 metadata lock
- MDL不需要显示使用，在访问一个表的时候会被自动加上
- 用来保证读写的正确性
- 当对一个表进行增删改查的时候加MDL读锁
- 当对表结构做变更的时候，加一个MDL写锁
- 读锁之间不互斥，因此一个表可以有多个增删改查
- 读写锁之间，写锁之间是互斥的，用来保证变更表结构操作的安全性
- MDL会持续到事务提交才释放，做表结构变更的时候容易锁住线上的查询和更新

### 行锁
- 针对数据表中行记录的锁

### 两阶段锁
- 行锁在需要的时候被加上，但是不会立刻释放，要等到事务结束时才释放
- 事务中需要锁多个行，把最可能造成行锁冲突，最可能影响并发度的锁尽量往后放

### 死锁
- 并发系统中不同线程出现资源依赖，涉及的线程都在等待其他线程释放资源，导致线程进入无限等待状态，就是死锁

### 死锁策略
- 直接进入等待，直到超时，超时时间通过innodb_lock_wait_timeout来设置
- 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行，参数innodb_deadlock_detect 设置为on

### 主动死锁检测
- 每个线程都会检查会不会因为自己的加入导致了死锁，线程数量多的情况下，每个线程循环检测会耗费大量CPU

### 解决方案
- 关闭死锁检测，死锁等待超时报错后，业务重试
- 控制并发线程数量
- 调整业务逻辑，顺序无关的逻辑随机选择一条执行
