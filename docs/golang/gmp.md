### G
- goroutine 缩写，每次go func()都代表一个G，无限制
- 使用struct runtime.g，包含了当前goroutine的状态，堆栈和上下文

### M
- 工作线程（OS thread）也被称为Machine，使用 struct  runtime.m，所有M是有线程栈的（1-8M）
- 如果不对该线程栈提供内存的话，系统会给该线程栈提供内存(不同操作系统提供的线程栈大小不同)。当指定了线程栈，则 M.stack→G.stack，M 的 PC 寄存器指向 G 提供的函数，然后去执行

### P
- Processor是一个抽象概念，并不是真正的物理CPU
- 代表了M所需的上下文环境，也是处理用户级代码逻辑的处理器。负责衔接M和G的调度上下文，将等待执行的G和M进行连接。当P有任务是需要创建或者唤醒一个M来执行 它队列里的任务，所以P/M需要进行绑定，构成一个执行单元
- P决定了并发任务的数量，通过runtime.GOMAXPROCS来设定，Go1.5之后被默认设置为可用核数，之前默认设置为1