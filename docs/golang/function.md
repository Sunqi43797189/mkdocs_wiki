### 函数参数
- 实际参数：函数实际调用时传入的参数
- 形式参数：把参数列表中的参数
![](/images/golang/function.jpg)

### 传参
- 函数参数传递采用是值传递的方式
- 所谓“值传递”，就是将实际参数在内存中的表示逐位拷贝（Bitwise Copy）到形式参数中
- 对于像整型、数组、结构体这类类型，它们的内存表示就是它们自身的数据内容，因此当这些类型作为实参类型时，值传递拷贝的就是它们自身，传递的开销也与它们自身的大小成正比
- 像 string、切片、map 这些类型它们的内存表示对应的是它们数据内容的“描述符”。当这些类型作为实参类型时，值传递拷贝的也是它们数据内容的“描述符”，不包括数据内容本身，所以这些类型传递的开销是固定的，与数据内容大小无关

### 函数传参例外
- 对于类型为接口类型的形参，Go 编译器会把传递的实参赋值给对应的接口类型形参
- 对于为变长参数的形参，Go 编译器会将零个或多个实参按一定形式转换为对应的变长形参
- 变长参数实际上是通过切片来实现

### Go函数特征
- 多个可以命名的返回值
- 函数可以存储在变量中
- 支持在函数内创建并通过返回值返回
- 可以作为参数传入函数
- 拥有自己的类型`type HandlerFunc func(ResponseWriter, *Request)`

### 函数健壮性原则
- 不要相信任何外部输入的参数
- 不要忽略任何一个错误
- 不要假定异常不会发生

### 方法
- Go 语言中的方法的本质就是，一个以方法的 receiver 参数作为第一个参数的普通函数
![](/images/golang/methods.jpg)
- 方法支持赋值给变量，相当于第一个参数是结构体自身或者自身的指针类型
```go
package main

import "fmt"

type T struct{}

func (t *T) M(n int) {
	fmt.Println(n)
}

func (t T)N(n int) {
	fmt.Println(n)
}

func main() {
	m1 := (*T).M
	m1(&T{}, 2)

	m2 := T.N
	m2(T{}, 3)
}
```

### 方法接收receiver
```go
func (t *T或T) MethodName(参数列表) (返回值列表) {
    // 方法体
}
```
- T为基类型
- receiver 参数的基类型本身不能为指针类型或接口类型
- 每个方法只能有一个 receiver 参数
- Go 不支持在方法的 receiver 部分放置包含多个 receiver 参数的参数列表，或者变长 receiver 参数
- 方法接收器（receiver）参数、函数 / 方法参数，以及返回值变量对应的作用域范围，都是函数 / 方法体对应的显式代码块
- receiver 部分的参数名不能与方法参数列表中的形参名，以及具名返回值中的变量名存在冲突，必须在这个方法的作用域中具有唯一性
- 如果在方法体中，我们没有用到 receiver 参数，我们也可以省略 receiver 的参数名

### 方法声明约束
- 方法声明要与 receiver 参数的基类型声明放在同一个包内
- 不能为原生类型（诸如 int、float64、map 等）添加方法
- 不能跨越 Go 包为其他包的类型声明新方法


### 方法调用
- receiver 参数的基类型为 T，receiver 参数绑定在 T 上，可以通过 *T 或 T 的变量实例调用该方法